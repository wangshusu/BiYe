C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          #define uchar unsigned char   // 以后unsigned char就可以用uchar代替
   5          #define uint  unsigned int    // 以后unsigned int 就可以用uint 代替
   6          
   7          sbit CS=P1^6;   //CS定义为P3口的第2位脚，连接ADC0832CS脚  PCB
   8          sbit SCL=P1^7;  //SCL定义为P3口的第3位脚，连接ADC0832SCL脚
   9          sbit DO=P3^0;   //DO定义为P3口的第4位脚，连接ADC0832DO脚
  10            
  11          sbit IRIN = P3^2;         //红外接收器数据线
  12          uchar IRCOM[7];             //成功接收标志
  13          
  14          sbit SCK_P      = P1^0;       // 时钟芯片DS1302的SCK管脚
  15          sbit SDA_P      = P1^1;       // 时钟芯片DS1302的SDA管脚
  16          sbit RST_P      = P1^2;       // 时钟芯片DS1302的RST管脚
  17          sbit LcdRs_P    = P1^3;       // 1602液晶的RS管脚       
  18          sbit LcdRw_P    = P1^4;       // 1602液晶的RW管脚 
  19          sbit LcdEn_P    = P1^5;       // 1602液晶的EN管脚
  20          sbit KeyMode_P  = P3^3;       // 模式切换
  21          sbit KeySet_P   = P3^4;       // 设置时间按键
  22          sbit KeySet2_P  = P3^5;       // 设置时间模式的开关时间和光照控制强度
  23          sbit KeyDown_P  = P3^6;       // 减按键
  24          sbit KeyUp_P    = P3^7;       // 加按键
  25          sbit Led_P      = P2^0;       // 指示灯
  26          
  27          uchar gMode=1;                // 1是手动模式，2是时间自动模式，3是亮度自动模式
  28          uchar OpenHour    = 18;       // 开启窗帘的小时
  29          uchar OpenMinute  = 20;       // 开启窗帘的分钟
  30          uchar CloseHour   = 10;       // 关闭窗帘的小时
  31          uchar CloseMinute = 30;       // 关闭窗帘的分钟
  32          uchar gLight      = 40;       // 窗帘开关的阈值
  33          
  34          uchar code Clock[]={0x10,0x20,0x40,0x80};       // 步进电机顺时针旋转数组
  35          uchar code AntiClock[]={0x80,0x40,0x20,0x10};   // 步进电机逆时针旋转数组
  36          
  37          uchar TimeBuff[7]={17,9,1,6,18,30,40};          // 时间数组，默认2017年9月1日，星期五，18:30:40
  38          // TimeBuff[0] 代表年份，范围00-99
  39          // TimeBuff[1] 代表月份，范围1-12
  40          // TimeBuff[2] 代表日期，范围1-31
  41          // TimeBuff[3] 代表星期，范围1-7
  42          // TimeBuff[4] 代表小时，范围00-23
  43          // TimeBuff[5] 代表分钟，范围00-59
  44          // TimeBuff[6] 代表秒钟，范围00-59
  45          
  46          /*********************************************************/
  47          // 毫秒级的延时函数，time是要延时的毫秒数
  48          /*********************************************************/
  49          void DelayMs(uint time)
  50          {
  51   1        uint i,j;
  52   1        for(i=0;i<time;i++)
  53   1          for(j=0;j<112;j++);
  54   1      }
  55          
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 2   

  56          /*********************************************************/
  57          // 1602液晶写命令函数，cmd就是要写入的命令
  58          /*********************************************************/
  59          void LcdWriteCmd(uchar cmd)
  60          { 
  61   1        LcdRs_P = 0;
  62   1        LcdRw_P = 0;
  63   1        LcdEn_P = 0;
  64   1        P0=cmd;
  65   1        DelayMs(2);
  66   1        LcdEn_P = 1;    
  67   1        DelayMs(2);
  68   1        LcdEn_P = 0;  
  69   1      }
  70          
  71          
  72          /*********************************************************/
  73          // 1602液晶写数据函数，dat就是要写入的数据
  74          /*********************************************************/
  75          void LcdWriteData(uchar dat)
  76          {
  77   1        LcdRs_P = 1; 
  78   1        LcdRw_P = 0;
  79   1        LcdEn_P = 0;
  80   1        P0=dat;
  81   1        DelayMs(2);
  82   1        LcdEn_P = 1;    
  83   1        DelayMs(2);
  84   1        LcdEn_P = 0;
  85   1      }
  86          
  87          
  88          /*********************************************************/
  89          // 1602液晶初始化函数
  90          /*********************************************************/
  91          void LcdInit()
  92          {
  93   1        LcdWriteCmd(0x38);        // 16*2显示，5*7点阵，8位数据口
  94   1        LcdWriteCmd(0x0C);        // 开显示，不显示光标
  95   1        LcdWriteCmd(0x06);        // 地址加1，当写入数据后光标右移
  96   1        LcdWriteCmd(0x01);        // 清屏
  97   1      }
  98          
  99          
 100          /*********************************************************/
 101          // 液晶光标定位函数
 102          /*********************************************************/
 103          void LcdGotoXY(uchar line,uchar column)
 104          {
 105   1        // 第一行
 106   1        if(line==0)        
 107   1          LcdWriteCmd(0x80+column); 
 108   1        // 第二行
 109   1        if(line==1)        
 110   1          LcdWriteCmd(0x80+0x40+column); 
 111   1      }
 112          
 113          
 114          /*********************************************************/
 115          // 液晶输出字符串函数
 116          /*********************************************************/
 117          void LcdPrintStr(uchar *str)
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 3   

 118          {
 119   1        while(*str!='\0')
 120   1            LcdWriteData(*str++);
 121   1      }
 122          
 123          
 124          /*********************************************************/
 125          // 液晶输出数字(0-99)
 126          /*********************************************************/
 127          void LcdPrintNum(uchar num)
 128          {
 129   1        LcdWriteData(num/10+48);    // 十位
 130   1        LcdWriteData(num%10+48);    // 个位
 131   1      }
 132          
 133          
 134          /*********************************************************/
 135          // 显示模式
 136          /*********************************************************/
 137          void LcdPrintMode(uchar num)
 138          {
 139   1        switch(num)     
 140   1        {
 141   2          case 1: LcdPrintStr("Manual");  break;
 142   2          case 2: LcdPrintStr("Timing");  break;
 143   2          case 3: LcdPrintStr("Liging");  break;
 144   2          default:                        break;
 145   2        }
 146   1      }
 147          
 148          
 149          /*********************************************************/
 150          // 液晶显示内容的初始化
 151          /*********************************************************/
 152          void LcdShowInit()
 153          {
 154   1        LcdGotoXY(0,0);
 155   1        LcdPrintStr("20  -  -     :  ");
 156   1        LcdGotoXY(1,0);
 157   1        LcdPrintStr("           gz:  ");
 158   1        LcdGotoXY(1,0);
 159   1        LcdPrintMode(gMode);
 160   1      }
 161          
 162          
 163          
 164          /*********************************************************/
 165          // 刷新时间显示
 166          /*********************************************************/
 167          void FlashTime()
 168          {
 169   1        LcdGotoXY(0,2);                   // 年份
 170   1        LcdPrintNum(TimeBuff[0]);
 171   1        LcdGotoXY(0,5);                   // 月份
 172   1        LcdPrintNum(TimeBuff[1]);
 173   1        LcdGotoXY(0,8);                   // 日期
 174   1        LcdPrintNum(TimeBuff[2]);
 175   1        LcdGotoXY(0,11);                  // 小时
 176   1        LcdPrintNum(TimeBuff[4]);
 177   1        LcdGotoXY(0,14);                  // 分钟
 178   1        LcdPrintNum(TimeBuff[5]);
 179   1        LcdGotoXY(0,13);                  // 秒钟
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 4   

 180   1        if(TimeBuff[6]%2==0)              // 秒钟是偶数显示冒号
 181   1          LcdWriteData(':');
 182   1        else                              // 秒钟是奇数显示空格
 183   1          LcdWriteData(' ');
 184   1      }
 185          
 186          
 187          /*********************************************************/
 188          // 初始化DS1302
 189          /*********************************************************/
 190          void DS1302_Init(void)
 191          {
 192   1        RST_P=0;      // RST脚置低
 193   1        SCK_P=0;      // SCK脚置低
 194   1        SDA_P=0;      // SDA脚置低        
 195   1      }
 196          
 197          
 198          /*********************************************************/
 199          // 从DS1302读出一字节数据
 200          /*********************************************************/
 201          uchar DS1302_Read_Byte(uchar addr) 
 202          {
 203   1        uchar i;
 204   1        uchar temp;
 205   1        
 206   1        RST_P=1;                
 207   1        
 208   1        /* 写入目标地址：addr*/
 209   1        for(i=0;i<8;i++) 
 210   1        {     
 211   2          if(addr&0x01) 
 212   2            SDA_P=1;
 213   2          else 
 214   2            SDA_P=0;
 215   2          
 216   2          SCK_P=1;
 217   2          _nop_();
 218   2          SCK_P=0;
 219   2          _nop_();
 220   2          
 221   2          addr=addr>> 1;
 222   2        }
 223   1        
 224   1        /* 读出该地址的数据 */
 225   1        for(i=0;i<8;i++) 
 226   1        {
 227   2          temp=temp>>1;
 228   2          
 229   2          if(SDA_P) 
 230   2            temp|= 0x80;
 231   2          else 
 232   2            temp&=0x7F;
 233   2          
 234   2          SCK_P=1;
 235   2          _nop_();
 236   2          SCK_P=0;
 237   2          _nop_();
 238   2        }
 239   1        
 240   1        RST_P=0;
 241   1        
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 5   

 242   1        return temp;
 243   1      }
 244          
 245          
 246          /*********************************************************/
 247          // 向DS1302写入一字节数据
 248          /*********************************************************/
 249          void DS1302_Write_Byte(uchar addr, uchar dat)
 250          {
 251   1        uchar i;
 252   1        
 253   1        RST_P = 1;
 254   1        
 255   1        /* 写入目标地址：addr*/
 256   1        for(i=0;i<8;i++) 
 257   1        { 
 258   2          if(addr&0x01) 
 259   2            SDA_P=1;
 260   2          else 
 261   2            SDA_P=0;
 262   2      
 263   2          SCK_P=1;
 264   2          _nop_();
 265   2          SCK_P=0;
 266   2          _nop_();
 267   2          
 268   2          addr=addr>>1;
 269   2        }
 270   1        
 271   1        /* 写入数据：dat*/
 272   1        for(i=0;i<8;i++) 
 273   1        {
 274   2          if(dat&0x01) 
 275   2            SDA_P=1;
 276   2          else 
 277   2            SDA_P=0;
 278   2        
 279   2          SCK_P=1;
 280   2          _nop_();
 281   2          SCK_P=0;
 282   2          _nop_();
 283   2          
 284   2          dat=dat>>1;
 285   2        }
 286   1        
 287   1        RST_P=0;          
 288   1      }
 289          /*********************************************************/
 290          // 向DS1302写入时间数据
 291          /*********************************************************/
 292          void DS1302_Write_Time() 
 293          {
 294   1        uchar i;
 295   1        uchar temp1;
 296   1        uchar temp2;
 297   1        
 298   1        for(i=0;i<7;i++)      // 十进制转BCD码
 299   1        {
 300   2          temp1=(TimeBuff[i]/10)<<4;
 301   2          temp2=TimeBuff[i]%10;
 302   2          TimeBuff[i]=temp1+temp2;
 303   2        }
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 6   

 304   1        
 305   1        DS1302_Write_Byte(0x8E,0x00);               // 关闭写保护 
 306   1        DS1302_Write_Byte(0x80,0x80);               // 暂停时钟 
 307   1        DS1302_Write_Byte(0x8C,TimeBuff[0]);        // 年 
 308   1        DS1302_Write_Byte(0x88,TimeBuff[1]);        // 月 
 309   1        DS1302_Write_Byte(0x86,TimeBuff[2]);        // 日 
 310   1        DS1302_Write_Byte(0x8A,TimeBuff[3]);        // 星期
 311   1        DS1302_Write_Byte(0x84,TimeBuff[4]);        // 时 
 312   1        DS1302_Write_Byte(0x82,TimeBuff[5]);        // 分
 313   1        DS1302_Write_Byte(0x80,TimeBuff[6]);        // 秒
 314   1        DS1302_Write_Byte(0x80,TimeBuff[6]&0x7F);   // 运行时钟
 315   1        DS1302_Write_Byte(0x8E,0x80);               // 打开写保护  
 316   1      }
 317          
 318          
 319          
 320          /*********************************************************/
 321          // 从DS1302读出时间数据
 322          /*********************************************************/
 323          void DS1302_Read_Time()  
 324          { 
 325   1        uchar i;
 326   1      
 327   1        TimeBuff[0]=DS1302_Read_Byte(0x8D);           // 年 
 328   1        TimeBuff[1]=DS1302_Read_Byte(0x89);           // 月 
 329   1        TimeBuff[2]=DS1302_Read_Byte(0x87);           // 日 
 330   1        TimeBuff[3]=DS1302_Read_Byte(0x8B);           // 星期
 331   1        TimeBuff[4]=DS1302_Read_Byte(0x85);           // 时 
 332   1        TimeBuff[5]=DS1302_Read_Byte(0x83);           // 分 
 333   1        TimeBuff[6]=(DS1302_Read_Byte(0x81))&0x7F;    // 秒 
 334   1      
 335   1        for(i=0;i<7;i++)    // BCD转十进制
 336   1        {           
 337   2          TimeBuff[i]=(TimeBuff[i]/16)*10+TimeBuff[i]%16;
 338   2        }
 339   1      }
 340          unsigned char ad0832read(bit SGL,bit ODD)
 341          {
 342   1        unsigned char i=0,value=0,value1=0;   
 343   1          SCL=0;
 344   1          DO=1;
 345   1          CS=0;   //开始
 346   1          SCL=1;    //第一个上升沿  
 347   1          SCL=0;
 348   1          DO=SGL;
 349   1          SCL=1;    //第二个上升沿
 350   1          SCL=0;
 351   1          DO=ODD;
 352   1          SCL=1;      //第三个上升沿
 353   1          SCL=0;      //第三个下降沿
 354   1          DO=1;
 355   1          for(i=0;i<8;i++)
 356   1          {
 357   2            SCL=1;
 358   2            SCL=0; //开始从第四个下降沿接收数据
 359   2            value<<=1;
 360   2            if(DO)
 361   2              value++;            
 362   2          }
 363   1          for(i=0;i<8;i++)
 364   1          {     //接收校验数据
 365   2            value1>>=1;
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 7   

 366   2            if(DO)
 367   2              value1+=0x80;
 368   2            SCL=1;
 369   2            SCL=0;
 370   2          }
 371   1          CS=1;
 372   1          SCL=1;  
 373   1          if(value==value1)       //与校验数据比较，正确就返回数据，否则返回0 
 374   1            return value;
 375   1        return 0;
 376   1      }
 377          /*********************************************************/
 378          // 按键扫描(设置当前时间)
 379          /*********************************************************/
 380          void KeyScanf1()
 381          {
 382   1        if(KeySet_P==0)
 383   1        {
 384   2          LcdGotoXY(0,13);        // 显示秒钟的冒号
 385   2          LcdWriteData(':');
 386   2          LcdWriteCmd(0x0f);      // 启动光标闪烁
 387   2          LcdGotoXY(0,3);         // 定位光标到年份闪烁
 388   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 389   2          while(!KeySet_P);       // 等待按键释放
 390   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 391   2          
 392   2          /* 调整年份 */
 393   2          while(1)
 394   2          {
 395   3            if(KeyDown_P==0)              // 如果减按键被下去
 396   3            {
 397   4              if(TimeBuff[0]>0)           // 判断年份是否大于0    
 398   4                TimeBuff[0]--;            // 是的话就减去1
 399   4              LcdGotoXY(0,2);             // 光标定位到年份的位置
 400   4              LcdPrintNum(TimeBuff[0]);   // 刷新显示改变后的年份
 401   4              LcdGotoXY(0,3);             // 定位光标到年份闪烁
 402   4              DelayMs(300);               // 延时0.3秒左右
 403   4            }
 404   3            
 405   3            if(KeyUp_P==0)                // 如果加按键被下去
 406   3            {
 407   4              if(TimeBuff[0]<99)          // 判断年份是否小于99
 408   4                TimeBuff[0]++;            // 是的话就加上1
 409   4              LcdGotoXY(0,2);             // 光标定位到年份的位置
 410   4              LcdPrintNum(TimeBuff[0]);   // 刷新显示改变后的年份
 411   4              LcdGotoXY(0,3);             // 定位光标到年份闪烁
 412   4              DelayMs(300);               // 延时0.3秒左右
 413   4            }
 414   3            
 415   3            if(KeySet_P==0)
 416   3            {
 417   4              break;
 418   4            }
 419   3          }
 420   2          
 421   2          LcdGotoXY(0,6);         // 定位光标到月份闪烁
 422   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 423   2          while(!KeySet_P);       // 等待按键释放
 424   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 425   2            
 426   2          /* 调整月份 */
 427   2          while(1)
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 8   

 428   2          {
 429   3            if(KeyDown_P==0)              // 如果减按键被下去
 430   3            {
 431   4              if(TimeBuff[1]>1)           // 判断月份是否大于1    
 432   4                TimeBuff[1]--;            // 是的话就减去1
 433   4              LcdGotoXY(0,5);             // 光标定位到月份的位置
 434   4              LcdPrintNum(TimeBuff[1]);   // 刷新显示改变后的月份
 435   4              LcdGotoXY(0,6);             // 定位光标到月份闪烁
 436   4              DelayMs(300);               // 延时0.3秒左右
 437   4            }
 438   3            
 439   3            if(KeyUp_P==0)                // 如果加按键被下去
 440   3            {
 441   4              if(TimeBuff[1]<12)          // 判断月份是否小于12
 442   4                TimeBuff[1]++;            // 是的话就加上1
 443   4              LcdGotoXY(0,5);             // 光标定位到月份的位置
 444   4              LcdPrintNum(TimeBuff[1]);   // 刷新显示改变后的月份
 445   4              LcdGotoXY(0,6);             // 定位光标到月份闪烁
 446   4              DelayMs(300);               // 延时0.3秒左右
 447   4            }
 448   3            
 449   3            if(KeySet_P==0)
 450   3            {
 451   4              break;
 452   4            }
 453   3          }
 454   2          
 455   2          LcdGotoXY(0,9);         // 定位光标到日期闪烁
 456   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 457   2          while(!KeySet_P);       // 等待按键释放
 458   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 459   2          
 460   2          /* 调整日期 */
 461   2          while(1)
 462   2          {
 463   3            if(KeyDown_P==0)              // 如果减按键被下去
 464   3            {
 465   4              if(TimeBuff[2]>1)           // 判断日期是否大于1    
 466   4                TimeBuff[2]--;            // 是的话就减去1
 467   4              LcdGotoXY(0,8);             // 光标定位到日期的位置
 468   4              LcdPrintNum(TimeBuff[2]);   // 刷新显示改变后的日期
 469   4              LcdGotoXY(0,9);             // 定位光标到日期闪烁
 470   4              DelayMs(300);               // 延时0.3秒左右
 471   4            }
 472   3            
 473   3            if(KeyUp_P==0)                // 如果加按键被下去
 474   3            {
 475   4              if(TimeBuff[2]<31)          // 判断日期是否小于31
 476   4                TimeBuff[2]++;            // 是的话就加上1
 477   4              LcdGotoXY(0,8);             // 光标定位到日期的位置
 478   4              LcdPrintNum(TimeBuff[2]);   // 刷新显示改变后的日期
 479   4              LcdGotoXY(0,9);             // 定位光标到日期闪烁
 480   4              DelayMs(300);               // 延时0.3秒左右
 481   4            }
 482   3            
 483   3            if(KeySet_P==0)
 484   3            {
 485   4              break;
 486   4            }
 487   3          }
 488   2          
 489   2          LcdGotoXY(0,12);        // 定位光标到小时闪烁
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 9   

 490   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 491   2          while(!KeySet_P);       // 等待按键释放
 492   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 493   2          
 494   2          
 495   2          /* 调整小时 */
 496   2          while(1)
 497   2          {
 498   3            if(KeyDown_P==0)              // 如果减按键被下去
 499   3            {
 500   4              if(TimeBuff[4]>0)           // 判断小时是否大于0
 501   4                TimeBuff[4]--;            // 是的话就减去1
 502   4              LcdGotoXY(0,11);            // 光标定位到小时的位置
 503   4              LcdPrintNum(TimeBuff[4]);   // 刷新显示改变后的小时
 504   4              LcdGotoXY(0,12);            // 定位光标到小时闪烁
 505   4              DelayMs(300);               // 延时0.3秒左右
 506   4            }
 507   3            
 508   3            if(KeyUp_P==0)                // 如果加按键被下去
 509   3            {
 510   4              if(TimeBuff[4]<23)          // 判断小时是否小于23
 511   4                TimeBuff[4]++;            // 是的话就加上1
 512   4              LcdGotoXY(0,11);            // 光标定位到小时的位置
 513   4              LcdPrintNum(TimeBuff[4]);   // 刷新显示改变后的小时
 514   4              LcdGotoXY(0,12);            // 定位光标到小时闪烁
 515   4              DelayMs(300);               // 延时0.3秒左右
 516   4            }
 517   3            
 518   3            if(KeySet_P==0)
 519   3            {
 520   4              break;
 521   4            }
 522   3          }
 523   2          
 524   2          LcdGotoXY(0,15);        // 定位光标到分钟闪烁
 525   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 526   2          while(!KeySet_P);       // 等待按键释放
 527   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 528   2          
 529   2          /* 调整分钟 */
 530   2          while(1)
 531   2          {
 532   3            if(KeyDown_P==0)              // 如果减按键被下去
 533   3            {
 534   4              if(TimeBuff[5]>0)           // 判断分钟是否大于0
 535   4                TimeBuff[5]--;            // 是的话就减去1
 536   4              LcdGotoXY(0,14);            // 光标定位到分钟的位置
 537   4              LcdPrintNum(TimeBuff[5]);   // 刷新显示改变后的分钟
 538   4              LcdGotoXY(0,15);            // 定位光标到分钟闪烁
 539   4              DelayMs(300);               // 延时0.3秒左右
 540   4            }
 541   3            
 542   3            if(KeyUp_P==0)                // 如果加按键被下去
 543   3            {
 544   4              if(TimeBuff[5]<59)          // 判断分钟是否小于59
 545   4                TimeBuff[5]++;            // 是的话就加上1
 546   4              LcdGotoXY(0,14);            // 光标定位到分钟的位置
 547   4              LcdPrintNum(TimeBuff[5]);   // 刷新显示改变后的分钟
 548   4              LcdGotoXY(0,15);            // 定位光标到分钟闪烁
 549   4              DelayMs(300);               // 延时0.3秒左右
 550   4            }
 551   3            
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 10  

 552   3            if(KeySet_P==0)
 553   3            {
 554   4              break;
 555   4            }
 556   3          }
 557   2          
 558   2          /* 退出前的设置 */
 559   2          LcdWriteCmd(0x0C);      // 关闭光标闪烁
 560   2          DS1302_Write_Time();    // 把新设置的时间值存入DS1302芯片
 561   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 562   2          while(!KeySet_P);       // 等待按键释放
 563   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 564   2        }
 565   1      }
 566          
 567          
 568          /*********************************************************/
 569          // 按键扫描(设置窗帘的动作)
 570          /*********************************************************/
 571          void KeyScanf2()
 572          {
 573   1        if(KeySet2_P==0)
 574   1        {
 575   2          LcdGotoXY(0,0);                   // 光标定位
 576   2          LcdPrintStr(" OpenTime   :   ");  // 显示第1行内容
 577   2          LcdGotoXY(1,0);                   // 光标定位
 578   2          LcdPrintStr("CloseTime   :   ");  // 显示第2行内容
 579   2          LcdGotoXY(0,10);                  // 光标定位
 580   2          LcdPrintNum(OpenHour);            // 显示开启窗帘的小时
 581   2          LcdGotoXY(0,13);                  // 光标定位
 582   2          LcdPrintNum(OpenMinute);          // 显示开启窗帘的分钟
 583   2          LcdGotoXY(1,10);                  // 光标定位
 584   2          LcdPrintNum(CloseHour);           // 显示关闭窗帘的小时
 585   2          LcdGotoXY(1,13);                  // 光标定位
 586   2          LcdPrintNum(CloseMinute);         // 显示关闭窗帘的分钟   
 587   2          
 588   2          LcdWriteCmd(0x0f);              // 启动光标闪烁
 589   2          LcdGotoXY(0,11);                // 定位光标
 590   2          DelayMs(10);                    // 延时等待，消除按键按下的抖动
 591   2          while(!KeySet2_P);              // 等待按键释放
 592   2          DelayMs(10);                    // 延时等待，消除按键松开的抖动
 593   2          
 594   2          /* 调整开启的小时 */
 595   2          while(1)
 596   2          {
 597   3            if(KeyDown_P==0)              // 如果减按键被下去
 598   3            {
 599   4              if(OpenHour>0)              // 判断小时是否大于0    
 600   4                OpenHour--;               // 是的话就减去1
 601   4              LcdGotoXY(0,10);            // 光标定位
 602   4              LcdPrintNum(OpenHour);      // 刷新显示改变后的小时
 603   4              LcdGotoXY(0,11);            // 定位光标
 604   4              DelayMs(300);               // 延时0.3秒左右
 605   4            }
 606   3            
 607   3            if(KeyUp_P==0)                // 如果加按键被下去
 608   3            {
 609   4              if(OpenHour<23)             // 判断小时是否小于23
 610   4                OpenHour++;               // 是的话就加上1
 611   4              LcdGotoXY(0,10);            // 光标定位
 612   4              LcdPrintNum(OpenHour);      // 刷新显示改变后的小时
 613   4              LcdGotoXY(0,11);            // 定位光标
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 11  

 614   4              DelayMs(300);               // 延时0.3秒左右
 615   4            }
 616   3            
 617   3            if(KeySet2_P==0)
 618   3            {
 619   4              break;
 620   4            }
 621   3          }
 622   2          
 623   2          LcdGotoXY(0,14);                // 定位光标
 624   2          DelayMs(10);                    // 延时等待，消除按键按下的抖动
 625   2          while(!KeySet2_P);              // 等待按键释放
 626   2          DelayMs(10);                    // 延时等待，消除按键松开的抖动
 627   2          
 628   2          /* 调整开启的分钟 */
 629   2          while(1)
 630   2          {
 631   3            if(KeyDown_P==0)              // 如果减按键被下去
 632   3            {
 633   4              if(OpenMinute>0)            // 判断分钟是否大于0
 634   4                OpenMinute--;             // 是的话就减去1
 635   4              LcdGotoXY(0,13);            // 光标定位
 636   4              LcdPrintNum(OpenMinute);    // 刷新显示改变后的分钟
 637   4              LcdGotoXY(0,14);            // 定位光标
 638   4              DelayMs(300);               // 延时0.3秒左右
 639   4            }
 640   3            
 641   3            if(KeyUp_P==0)                // 如果加按键被下去
 642   3            {
 643   4              if(OpenMinute<59)           // 判断分钟是否小于59
 644   4                OpenMinute++;             // 是的话就加上1
 645   4              LcdGotoXY(0,13);            // 光标定位
 646   4              LcdPrintNum(OpenMinute);    // 刷新显示改变后的分钟
 647   4              LcdGotoXY(0,14);            // 定位光标
 648   4              DelayMs(300);               // 延时0.3秒左右
 649   4            }
 650   3            
 651   3            if(KeySet2_P==0)
 652   3            {
 653   4              break;
 654   4            }
 655   3          }
 656   2          
 657   2          LcdGotoXY(1,11);                // 定位光标
 658   2          DelayMs(10);                    // 延时等待，消除按键按下的抖动
 659   2          while(!KeySet2_P);              // 等待按键释放
 660   2          DelayMs(10);                    // 延时等待，消除按键松开的抖动
 661   2          
 662   2          /* 调整关闭的小时 */
 663   2          while(1)
 664   2          {
 665   3            if(KeyDown_P==0)              // 如果减按键被下去
 666   3            {
 667   4              if(CloseHour>0)             // 判断小时是否大于0    
 668   4                CloseHour--;              // 是的话就减去1
 669   4              LcdGotoXY(1,10);            // 光标定位
 670   4              LcdPrintNum(CloseHour);     // 刷新显示改变后的小时
 671   4              LcdGotoXY(1,11);            // 定位光标
 672   4              DelayMs(300);               // 延时0.3秒左右
 673   4            }
 674   3            
 675   3            if(KeyUp_P==0)                // 如果加按键被下去
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 12  

 676   3            {
 677   4              if(CloseHour<23)            // 判断小时是否小于23
 678   4                CloseHour++;              // 是的话就加上1
 679   4              LcdGotoXY(1,10);            // 光标定位
 680   4              LcdPrintNum(CloseHour);     // 刷新显示改变后的小时
 681   4              LcdGotoXY(1,11);            // 定位光标
 682   4              DelayMs(300);               // 延时0.3秒左右
 683   4            }
 684   3            
 685   3            if(KeySet2_P==0)
 686   3            {
 687   4              break;
 688   4            }
 689   3          }
 690   2          
 691   2          LcdGotoXY(1,14);                // 定位光标
 692   2          DelayMs(10);                    // 延时等待，消除按键按下的抖动
 693   2          while(!KeySet2_P);              // 等待按键释放
 694   2          DelayMs(10);                    // 延时等待，消除按键松开的抖动
 695   2          
 696   2          /* 调整关闭的分钟 */
 697   2          while(1)
 698   2          {
 699   3            if(KeyDown_P==0)              // 如果减按键被下去
 700   3            {
 701   4              if(CloseMinute>0)           // 判断分钟是否大于0
 702   4                CloseMinute--;            // 是的话就减去1
 703   4              LcdGotoXY(1,13);            // 光标定位
 704   4              LcdPrintNum(CloseMinute);   // 刷新显示改变后的分钟
 705   4              LcdGotoXY(1,14);            // 定位光标
 706   4              DelayMs(300);               // 延时0.3秒左右
 707   4            }
 708   3            
 709   3            if(KeyUp_P==0)                // 如果加按键被下去
 710   3            {
 711   4              if(CloseMinute<59)          // 判断分钟是否小于59
 712   4                CloseMinute++;            // 是的话就加上1
 713   4              LcdGotoXY(1,13);            // 光标定位
 714   4              LcdPrintNum(CloseMinute);   // 刷新显示改变后的分钟
 715   4              LcdGotoXY(1,14);            // 定位光标
 716   4              DelayMs(300);               // 延时0.3秒左右
 717   4            }
 718   3            
 719   3            if(KeySet2_P==0)
 720   3            {
 721   4              break;
 722   4            }
 723   3          }
 724   2          
 725   2          DelayMs(10);                    // 延时等待，消除按键按下的抖动
 726   2          while(!KeySet2_P);              // 等待按键释放
 727   2          DelayMs(10);                    // 延时等待，消除按键松开的抖动
 728   2          
 729   2          /* 光照强度的设置 */
 730   2          LcdWriteCmd(0x0C);                // 关闭光标闪烁
 731   2          LcdGotoXY(0,0);                   // 光标定位
 732   2          LcdPrintStr("   Light Set    ");  // 显示第1行内容
 733   2          LcdGotoXY(1,0);                   // 光标定位
 734   2          LcdPrintStr("                ");  // 显示第2行内容
 735   2          LcdGotoXY(1,7);                   // 光标定位
 736   2          LcdPrintNum(gLight);              // 显示窗帘的光线控制强度阈值
 737   2          
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 13  

 738   2          while(1)
 739   2          {
 740   3            if(KeyDown_P==0)              // 如果减按键被下去
 741   3            {
 742   4              if(gLight>0)                // 判断光线阈值是否大于0
 743   4                gLight--;                 // 是的话就减去1
 744   4              LcdGotoXY(1,7);             // 光标定位
 745   4              LcdPrintNum(gLight);        // 刷新显示改变后的光线阈值
 746   4              DelayMs(300);               // 延时0.3秒左右
 747   4            }
 748   3            
 749   3            if(KeyUp_P==0)                // 如果加按键被下去
 750   3            {
 751   4              if(gLight<99)               // 判断光线阈值是否小于59
 752   4                gLight++;                 // 是的话就加上1
 753   4              LcdGotoXY(1,7);             // 光标定位
 754   4              LcdPrintNum(gLight);        // 刷新显示改变后的光线阈值
 755   4              DelayMs(300);               // 延时0.3秒左右
 756   4            }
 757   3            
 758   3            if(KeySet2_P==0)
 759   3            {
 760   4              break;
 761   4            }
 762   3          }
 763   2          
 764   2          /* 退出前的设置 */
 765   2          LcdShowInit();          // 液晶显示内容初始化
 766   2          DelayMs(10);            // 延时等待，消除按键按下的抖动
 767   2          while(!KeySet2_P);      // 等待按键释放
 768   2          DelayMs(10);            // 延时等待，消除按键松开的抖动
 769   2        }
 770   1      }
 771          
 772          
 773          /*********************************************************/
 774          // 按键扫描(模式切换)
 775          /*********************************************************/
 776          void KeyScanf3()
 777          {
 778   1        if(KeyMode_P==0)
 779   1        {
 780   2          gMode++;              // 切换到下一模式
 781   2          if(gMode==4)          // 如果到尽头了
 782   2            gMode=1;            // 回到第一种模式
 783   2          LcdGotoXY(1,0);       // 光标定位
 784   2          LcdPrintMode(gMode);  // 显示模式
 785   2          DelayMs(10);          // 去除按键按下的抖动
 786   2          while(!KeyMode_P);    // 等待按键是否
 787   2          DelayMs(10);          // 去除按键松开的抖动
 788   2        }
 789   1      }
 790          
 791          
 792          /*********************************************************/
 793          // 开窗0x10,0x20,0x40,0x80
 794          /*********************************************************/
 795          sbit dj1=P2^7;
 796          sbit dj2=P2^6;
 797          sbit dj3=P2^5;
 798          sbit dj4=P2^4;
 799          void Open()
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 14  

 800          {
 801   1        uint i,j;
 802   1        for(j=0;j<220;j++)    // 控制步进电机正转
 803   1        {
 804   2          for(i=0;i<4;i++)
 805   2          {
 806   3            //P2=Clock[i];
 807   3            if(i==0){dj4=1;dj3=0;dj2=0;dj1=0;}
 808   3            if(i==1){dj4=0;dj3=1;dj2=0;dj1=0;}
 809   3            if(i==2){dj4=0;dj3=0;dj2=1;dj1=0;}
 810   3            if(i==3){dj4=0;dj3=0;dj2=0;dj1=1;}
 811   3            DelayMs(3);
 812   3          }
 813   2        }
 814   1        Led_P=0;
 815   1      }
 816          
 817          
 818          
 819          /*********************************************************/
 820          // 关窗
 821          /*********************************************************/
 822          void Close()
 823          {
 824   1        uint i,j;
 825   1        for(j=0;j<220;j++)    // 控制步进电机反转
 826   1        {
 827   2          for(i=0;i<4;i++)
 828   2          {
 829   3            //P2=AntiClock[i];
 830   3            if(i==0){dj4=0;dj3=0;dj2=0;dj1=1;}
 831   3            if(i==1){dj4=0;dj3=0;dj2=1;dj1=0;}
 832   3            if(i==2){dj4=0;dj3=1;dj2=0;dj1=0;}
 833   3            if(i==3){dj4=1;dj3=0;dj2=0;dj1=0;}
 834   3            DelayMs(3);
 835   3          }
 836   2        }
 837   1        Led_P=1;
 838   1      }
 839          
 840          
 841          
 842          void init()//初始化函数
 843          {
 844   1          IE = 0x81;                 //允许总中断中断,使能 INT0 外部中断
 845   1          TCON = 0x01;               //触发方式为脉冲负边沿触发
 846   1          
 847   1          IRIN=1;                    //I/O口初始化
 848   1      }
 849          /*********************************************************/
 850          // 主函数
 851          /*********************************************************/
 852          void main()
 853          {
 854   1        uchar light;
 855   1        init();
 856   1        LcdInit();      // 执行液晶初始化 
 857   1        DS1302_Init();  // 时钟芯片的初始化
 858   1        LcdShowInit();  // 液晶显示内容的初始化
 859   1        
 860   1        if(DS1302_Read_Byte(0x81)>=128)     // 判断时钟芯片是否正在运行
 861   1        {
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 15  

 862   2          DS1302_Write_Time();              // 如果没有，则初始化一个时间
 863   2        }
 864   1        
 865   1        while(1)
 866   1        {
 867   2          DS1302_Read_Time();       // 获取当前时钟芯片的时间，存在数组time_buf中
 868   2          FlashTime();              // 刷新时间显示
 869   2      
 870   2          light=ad0832read(1,0);//Get_ADC0832();      // 读取光照强度
 871   2          light=light/2.5;          // 缩小光照检测结果(在0-99)
 872   2          if(light>99)              // 如果大于99
 873   2            light=99;               // 则依然保持99
 874   2          LcdGotoXY(1,14);          // 光标定位
 875   2          LcdPrintNum(light);       // 显示光照强度
 876   2          
 877   2          KeyScanf1();              // 按键扫描(时间的设置)
 878   2          KeyScanf2();              // 按键扫描(阈值的设置)
 879   2          KeyScanf3();              // 按键扫描(模式切换)
 880   2        
 881   2          /*手动控制模式*/
 882   2          if(gMode==1)
 883   2          {
 884   3            if(KeyDown_P==0)    // 如果关窗帘键按下了 
 885   3            {
 886   4              if(Led_P==0)      // 如果窗帘当前是打开的
 887   4              {
 888   5                Close();        // 则关闭窗帘
 889   5              }
 890   4            }
 891   3            if(KeyUp_P==0)      // 如果开窗帘键按下了
 892   3            {
 893   4              if(Led_P==1)      // 如果窗帘当前是关闭的
 894   4              {
 895   5                Open();         // 则打开窗帘
 896   5              }
 897   4            } 
 898   3          }
 899   2          
 900   2          /*时间控制模式*/
 901   2          if(gMode==2)
 902   2          {
 903   3            if((TimeBuff[4]==CloseHour)&&(TimeBuff[5]==CloseMinute)&&(TimeBuff[6]==0))  // 如果到了关窗帘的时间 
 904   3            {
 905   4              if(Led_P==0)      // 如果窗帘当前是打开的
 906   4              {
 907   5                Close();        // 则关闭窗帘
 908   5              }
 909   4            }
 910   3            if((TimeBuff[4]==OpenHour)&&(TimeBuff[5]==OpenMinute)&&(TimeBuff[6]==0))    // 如果到了开窗帘的时间 
 911   3            {
 912   4              if(Led_P==1)      // 如果窗帘当前是关闭的
 913   4              {
 914   5                Open();         // 则打开窗帘
 915   5              }
 916   4            } 
 917   3          }
 918   2          
 919   2          /*光线控制模式*/
 920   2          if(gMode==3)
 921   2          {
 922   3            if(light<gLight)    // 当前光线小于设置的阈值
 923   3            {
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 16  

 924   4              if(Led_P==0)      // 如果窗帘当前是打开的
 925   4              {
 926   5                Close();        // 则关闭窗帘
 927   5              }
 928   4            }
 929   3            else                // 当前光线大于或等于设置的阈值
 930   3            {
 931   4              if(Led_P==1)      // 如果窗帘当前是关闭的
 932   4              {
 933   5                Open();         // 则打开窗帘
 934   5              }
 935   4            } 
 936   3          }
 937   2          
 938   2          DelayMs(100);             // 延时0.1秒
 939   2        }
 940   1      }
 941          void delay(unsigned char x)    //x*0.14MS
 942          {
 943   1       unsigned char i;
 944   1        while(x--)
 945   1       {
 946   2        for (i = 0; i<13; i++) {}
 947   2       }
 948   1      }
 949          /**********************************************************/
 950          void IR_IN() interrupt 0 using 0
 951          {
 952   1        unsigned char j,k,N=0;
 953   1           EX0 = 0;   
 954   1         delay(15);
 955   1         if (IRIN==1) 
 956   1           { EX0 =1;
 957   2           return;
 958   2          } 
 959   1                                 //确认IR信号出现
 960   1        while (!IRIN)            //等IR变为高电平，跳过9ms的前导低电平信号。
 961   1          {delay(1);}
 962   1      
 963   1       for (j=0;j<4;j++)         //收集四组数据
 964   1       { 
 965   2        for (k=0;k<8;k++)        //每组数据有8位
 966   2        {
 967   3         while (IRIN)            //等 IR 变为低电平，跳过4.5ms的前导高电平信号。
 968   3           {delay(1);}
 969   3          while (!IRIN)          //等 IR 变为高电平
 970   3           {delay(1);}
 971   3           while (IRIN)           //计算IR高电平时长
 972   3            {
 973   4          delay(1);
 974   4          N++;           
 975   4          if (N>=30)
 976   4         { EX0=1;
 977   5         return;}                  //0.14ms计数过长自动离开。
 978   4            }                        //高电平计数完毕                
 979   3           IRCOM[j]=IRCOM[j] >> 1;                  //数据最高位补“0”
 980   3           if (N>=8) {IRCOM[j] = IRCOM[j] | 0x80;}  //数据最高位补“1”
 981   3           N=0;
 982   3        }//end for k
 983   2       }//end for j
 984   1        if(IRCOM[2]==0x45)//全灭
 985   1        {
C51 COMPILER V9.54   MAIN                                                                  04/30/2023 15:46:10 PAGE 17  

 986   2          if(gMode==1)
 987   2          {
 988   3            if(Led_P==0)      // 如果窗帘当前是打开的
 989   3            {
 990   4              Close();        // 则关闭窗帘
 991   4            } 
 992   3          }
 993   2        }
 994   1      
 995   1        if(IRCOM[2]==0x47)//全亮
 996   1        {
 997   2          if(gMode==1)
 998   2          {
 999   3            if(Led_P==1)      // 如果窗帘当前是关闭的
1000   3            {
1001   4              Open();         // 则打开窗帘
1002   4            } 
1003   3          }
1004   2        }
1005   1      
1006   1           EX0 = 1; 
1007   1      } 
1008          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2500    ----
   CONSTANT SIZE    =    131    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
