# 基于GEC6818开发平台的广告投放机的设计与实现

## 1. 第一章 绪论

### 1.1 本课题的研究背景

随着现代社会的迅速发展，广告已经成为推动市场发展的重要力量。根据市场研究机构的数据显示，全球广告市场规模在不断扩大，预计将在未来几年内达到数千亿美元的规模。其中，中国作为全球最大的广告市场之一，在近年来也取得了快速发展，2019年中国广告市场规模已经达到了5400亿人民币。

广告在企业金融中也发挥着重要作用。通过广告的投放，企业可以提高品牌知名度和产品销售量，进而实现收入的增长和市场份额的提升。同时，广告投放也可以促进产业链上下游的发展，从而推动整个经济的增长和就业的增加。

在广告的发展历程中，从最初的纸媒广告、电视广告，到互联网广告、移动广告等，广告行业经历了一步步的发展和变革。传统的广告投放方式已经不能满足市场需求，需要更加精准、高效的广告投放方式，以满足企业和消费者的需求。

广告投放机的研究和开发可以提高广告投放的效率和精准度，帮助企业更好地实现产品宣传和销售。此外，广告投放机的研究还可以为广告行业提供一种新的广告投放方式，促进广告行业的转型升级和技术创新，提升整个广告产业链的竞争力和创新力。

因此，本论文将围绕基于GEC6818开发平台的广告投放机的设计和实现展开研究，旨在为广告行业的发展提供一种新的广告投放方式，为企业实现产品宣传和销售提供更高效、更精准的解决方案。

### 1.2 嵌入式系统介绍

嵌入式系统是一种专门针对特定应用领域、具有实时性和可靠性要求的计算机系统。它采用了专用的硬件和软件设计，具有小型化、低功耗、高性能、高可靠性等特点，广泛应用于工业控制、汽车、医疗、通讯等领域。嵌入式技术的发展经历了多年的积累和演进，从单片机、DSP、ARM等技术的出现，到现在的物联网、人工智能等技术的广泛应用，嵌入式技术已经成为现代信息技术发展的重要支撑。

在中国，随着科技和经济的快速发展，嵌入式技术已经成为一个重要的发展领域。根据市场调研机构的数据显示，中国的嵌入式系统市场规模已经达到了数千亿的规模，预计在未来几年内还会持续增长。同时，随着人们对智能家居、智能穿戴等物联网应用的需求不断增加，嵌入式系统在中国的市场需求也将不断扩大。

嵌入式系统的优势主要体现在以下几个方面：

1. 可靠性高：嵌入式系统经过专门的设计和优化，能够保证高可靠性，从而满足特定领域的实时性和安全性要求。
2. 体积小、功耗低：由于嵌入式系统采用专用的硬件和软件设计，因此体积小、功耗低，非常适合于各种移动设备和智能终端的应用。
3. 可定制性强：嵌入式系统采用定制化设计，可以根据特定的应用领域和需求进行定制，提高系统的适应性和性能。
4. 成本低：嵌入式系统采用专用的硬件和软件设计，相对于传统计算机系统来说，成本更低，因此在大规模应用中具有更高的竞争优势。

我们的研发方向是基于GEC6818开发平台的广告投放机的设计与实现。这个研发方向具有以下几个优势：

1. 针对性强：广告投放机是针对特定应用领域的产品，通过深入研究市场需求和用户需求，我们可以设计出更加精准、高效的广告投放机。
2. 技术领先：基于GEC6818开发平台的广告投放机可以采用最新的嵌入式技术和软件开发技术，具有更高的性能和稳定性，能够满足市场对广告投放机的高要求。
3. 可扩展性强：基于GEC6818开发平台的广告投放机可以进行二次开发和扩展，可以根据不同的应用需求进行定制化设计，具有更高的适应性和灵活性。
4. 市场前景广泛：随着广告行业的不断发展和互联网、移动互联网的普及，广告投放机市场前景广阔。基于GEC6818开发平台的广告投放机在这个市场中具有更高的竞争力。

综上所述，嵌入式系统作为一种具有广泛应用前景的技术，已经成为现代信息技术发展的重要支撑。基于GEC6818开发平台的广告投放机的设计与实现具有针对性强、技术领先、可扩展性强、市场前景广泛等优势，可以满足市场对广告投放机的高要求，具有很高的应用价值和市场潜力。

### 1.3 广告机发展现状

广告机作为新型广告媒介，在近年来迅速发展，并逐渐取代了传统广告的地位。传统广告多采用传统媒体（如电视、报纸、广播等）进行投放，虽然有着较大的覆盖面和受众，但也存在着诸多不足，如传播效果难以测量、广告创意单一、投放成本高等问题。相比之下，广告机具有以下优势：

1. 内容更加灵活：广告机可以通过多媒体展示，将文字、图片、视频等多种形式的广告内容展现出来，且可以随时进行更改和更新，具有更高的灵活性和创新性。
2. 投放更加精准：广告机可以通过数据分析等技术手段，实现针对性广告投放，能够更好地满足受众需求，提高广告效果。
3. 成本更加低廉：广告机的制作和投放成本相对传统广告较低，且可以根据不同场合和需求进行灵活调整，节省成本。

在中国市场，广告机已经逐渐成为企业宣传、商品推广、品牌塑造等方面的重要手段，具有广阔的应用前景和经济规模。据统计，中国广告机市场规模已经超过了200亿元，年增长率超过20%。广告机的应用领域涵盖了商场、车站、机场、酒店、医院等多个场合，可以为企业提供全方位的品牌推广服务。

在广告机市场中，基于嵌入式系统的广告机具有更高的性能和稳定性，可以满足市场对广告机的高要求。此外，基于GEC6818开发平台的广告投放机还具有技术领先、可扩展性强、市场前景广泛等优势。因此，基于GEC6818开发平台的广告投放机的设计与实现具有重要的应用价值和市场潜力，是广告机市场的重要发展方向之一。

### 1.4 本课题的研究内容

本课题的研究内容主要是设计和开发一款基于GEC6818开发平台的广告投放机。项技术来实现这一目标，我们将运用多项技术来实现这一目标，其中包括C语言、shell脚本、交叉编译技术等。我们选用了Linux操作系统，并将运用多线程的知识、文件IO等技术来开发这个广告机。

本课题所做的主要工作为：

（1）查阅相关资料，熟悉在Linux环境下嵌入式的开发流程；

（2）对广告机的功能进行分析，确认广告机的设计方案、主要设计模块、使用的技术；

（3）学习和研究多线程编程理论，以及如何编写多线程的程序；

（4）搭建广告机的软硬件开发平台，交叉编译的环境，移植Linux系统；

（5）使用C语言编写广告机的应用程序，编译完成后在GEC6818开发板上测试；

### 1.5 论文结构

各个章节的内容安排如下：

第一章 	

本章介绍了本课题的研究背景和目的，讨论了嵌入式广告机系统的发展和现状，并介绍了本课题的研究内容和意义。描述了自己的工作。

第二章 	

本章确定了嵌入式广告机系统的总体设计方案，包括硬件资源和系统软件平台的选择。

第三章 	

本章介绍了如何搭建系统软件平台。包括交叉编译环境的建立，shell脚本的编写。对每个步骤的实现方法和注意事项都进行了详细介绍。

第四章 	

本章讨论了多任务机制和多线程编程的基本原理，确定了使用多线程编程实现广告机应用程序的方法。详细介绍了多线程编程中各个函数的原理和使用方法，如互斥锁、条件变量和线程池等。

第五章 	

本章介绍了如何来还原bmp图片和实现了广告机应用程序。通过运行测试，证明广告机系统基本功能正常，如文件播放和广告内容管理等。

第六章 	

本章对全文进行总结，提出本设计的不足，并对后续设计进行展望。讨论了本课题中存在的问题和未来研究的方向，如增加网络功能和用户交互界面等。

### 1.6 本章小结

本章节主要介绍了嵌入式广告机系统的设计与实现。首先，本章介绍了本课题的研究背景，阐述了广告在现代社会中的重要作用以及嵌入式技术的发展历程和在中国市场中的潜力和需求。接着，本章详细介绍了嵌入式系统的优势以及广告机在中国市场中的发展现状。然后，本章概述了本课题的研究内容，包括所需的技术和工具。最后，本章对本论文的结构进行了说明，包括各章节的内容安排和对全文的总结和展望。

## 2. 第二章 广告机系统方案选择

### 2.1 广告机系统总体设计方案

### 2.2 广告机硬件资源选择

广告机硬件资源选择是设计广告机系统的重要一步。在选择硬件资源时，需要考虑系统的需求和性能要求。常用的硬件资源包括处理器、存储器、屏幕等。

对于本设计，我们选择了GEC6818开发平台作为广告机的硬件平台。GEC6818开发平台采用了S5P6818处理器，该处理器采用ARM Cortex-A53架构，主频最高可达1.4GHz，具有较高的性能。此外，GEC6818开发平台还配备了1GB DDR3L内存和8GB eMMC存储器，可满足广告机系统对内存和存储的要求。

对于广告机的屏幕，**我们选择了7寸的LCD屏幕，分辨率为800x480。该屏幕具有较好的视觉效果，可以满足广告机对显示效果的要求。**

#### 2.2.1 ARM处理器介绍

ARM处理器是广告机系统中的重要组成部分。ARM处理器是一种基于精简指令集（RISC）架构的处理器，具有低功耗、高性能、低成本等特点。ARM处理器广泛应用于移动设备、嵌入式系统等领域。

ARM处理器的特点包括以下几个方面：

1. 高性能。ARM处理器采用了精简指令集（RISC）架构，具有较高的性能和较低的能耗。
2. 低功耗。ARM处理器具有低功耗的特点，适用于需要长时间待机或运行的设备。
3. 可扩展性。ARM处理器支持多种外围设备和接口，可以满足不同设备对接口和扩展性的需求。
4. 低成本。ARM处理器的成本相对较低，适用于大规模生产的设备。

在本设计中，我们选择了ARM Cortex-A53处理器作为广告机系统的主处理器，它可以满足广告机对处理性能和能耗的要求。

#### 2.2.2 ARM Cortex-A53处理器

ARM Cortex-A53处理器是一款基于ARMv8-A架构的32/64位RISC处理器。它采用了先进的7级流水线技术，拥有多种指令集和扩展指令，以提供更高的性能和更低的功耗。

该处理器采用了多核设计，每个核心可以独立运行，同时还支持SMP（对称多处理）和AMP（异构多处理）模式，以满足不同应用场景的需求。此外，该处理器还具有强大的浮点运算能力和多媒体处理能力，可以满足多种复杂应用场景的需求。

在能源效率方面，ARM Cortex-A53处理器采用了全新的big.LITTLE架构，将高性能和低功耗的核心集成在一起，以适应不同的应用场景和负载。在较低负载时，处理器会自动切换到低功耗核心，以降低功耗和延长电池续航时间。

此外，ARM Cortex-A53处理器还支持虚拟化技术，可以将物理资源虚拟化成多个逻辑资源，以提高资源利用率和降低成本。同时，它还具有丰富的接口和扩展能力，可以与多种外围设备和接口连接，以满足各种应用场景的需求。

综上所述，ARM Cortex-A53处理器是一款具有高性能、低功耗、多核设计和丰富接口的处理器，适用于多种应用场景，特别是移动设备、嵌入式系统和网络设备等领域。

### 2.3 嵌入式操作系统的选择

嵌入式软件开发有两种方式，分别是底层软件开发和上层软件开发。

底层软件开发主要是指针对硬件的底层驱动和操作系统内核的开发，包括硬件抽象层、设备驱动程序、中断处理程序等，需要对硬件的底层原理和寄存器编程有深入的了解和掌握。

上层软件开发则是在操作系统和驱动的基础上进行的应用程序开发，包括应用层程序、应用库、界面设计等，需要对操作系统的使用和应用开发有较深的理解和熟练的编程能力。

在嵌入式操作系统方面，目前市面上有多种主流的操作系统可供选择，其中比较流行的包括：

1. Linux：开源免费的操作系统，具有成熟的内核和庞大的生态系统，适用于各种类型的嵌入式设备和应用场景。
2. FreeRTOS：一个轻量级、实时性强的操作系统，适用于小型、低功耗的嵌入式设备。
3. uC/OS：一个基于微内核的实时操作系统，适用于各种类型的嵌入式设备和应用场景。

我们选择使用Linux操作系统的原因主要是因为其开源免费、成熟稳定、生态系统完善、具有良好的兼容性和扩展性等优点，同时也因为我们所选择的应用场景需要较强的功能性和开发灵活性，适用于上层软件开发。

### 2.4 本章小结

在本章中，我们介绍了广告机系统方案选择的过程，其中选择了基于GEC6818开发平台的广告机系统。我们还对广告机系统的硬件资源进行了选择，其中选择了ARM Cortex-A53处理器。同时，我们还选择了Linux操作系统作为嵌入式操作系统。综上所述，本章主要介绍了我们广告机系统的总体设计方案，包括硬件资源选择、处理器选择以及嵌入式操作系统的选择，为后续的广告机系统开发和实现打下了基础。

## 3. 第三章 广告机系统开发平台搭建

### 3.1 嵌入式交叉编译环境的建立

嵌入式设备通常由于存储空间和处理能力的限制，无法承载完整的Linux操作系统。完整的Linux操作系统包含了大量的软件包和库文件，需要较大的存储空间和较高的处理能力，完整的Linux操作系统也通常包含多种图形化界面和应用程序，这些功能在嵌入式设备中并不需要，因此也不应该占用宝贵的资源。因此，为了适应嵌入式设备的特性，需要对Linux操作系统进行裁剪，只保留必要的软件包和库文件，以达到最小化的体积和最高效的运行。这里再GEC6818开发板上移植好裁剪好的Linux操作系统，将编译好的程序移植到开发板，最后使其在开发板上运行。

#### 3.1.1 交叉编译工具链的安装

在进行交叉编译前，需要安装相应的交叉编译工具链。一般包括以下工具：

(1) binutils：这是一个包含链接器、汇编器和其他二进制工具的软件包，用于将源代码转换为可执行文件。

(2) gcc：GNU C编译器，用于将C和C++代码编译成可执行文件。

(3) libc：C库，是一组函数和头文件，用于编写C语言程序。

(4) 头文件和库文件：用于支持交叉编译，这些文件需要与目标平台相对应。

在GEC6818开发平台上，可以使用apt-get命令进行安装。具体步骤如下：

(1) 更新apt-get：

```bash
sudo apt-get update
```

(2) 安装交叉编译工具链：

```bash
sudo apt-get install gcc-arm-linux-gnueabi
```

这将安装一个名为“gcc-arm-linux-gnueabi”的软件包，其中包含所有必需的工具。

安装完交叉编译工具链后，还需要在环境变量中添加路径，这样在当前Linux系统下任何路径都能找到gcc命令，具体步骤如下：

1. 打开bashrc文件：

```bash
sudo nano ~/.bashrc
```

2. 在文件的末尾添加以下两行：

```bash
export PATH=$PATH:/usr/arm-linux-gnueabi/bin
export CROSS_COMPILE=arm-linux-gnueabi-
```

第一行将路径添加到系统路径中，以便可以访问交叉编译器和其他工具。第二行设置CROSS_COMPILE变量，这对于Makefile编译非常重要。

3. 保存并关闭文件。

4. 使更改生效：

```bash
source ~/.bashrc
```

现在，交叉编译工具链已经安装并配置好了环境变量，可以开始进行交叉编译了。

#### 3.1.2 安装配置TFTP服务

TFTP（Trivial File Transfer Protocol）是一种轻量级的文件传输协议，广泛应用于嵌入式设备和网络设备中。为了实现广告机的远程升级，需要在开发板上安装和配置TFTP服务器。本节将介绍如何在GEC6818开发板上安装和配置TFTP服务器。

首先，我们需要安装TFTP服务器。我们可以使用以下命令在开发板上安装TFTP服务器和客户端：

```
arduinoCopy code
sudo apt-get install tftpd-hpa tftp-hpa
```

安装完成后，我们需要配置TFTP服务器。我们可以编辑配置文件/etc/default/tftpd-hpa来设置TFTP服务器的根目录和其他选项。例如：

```makefile
TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/srv/tftp"
TFTP_ADDRESS="0.0.0.0:69"
TFTP_OPTIONS="--secure"
```

在上述配置中，TFTP_DIRECTORY是TFTP服务器的根目录，TFTP_ADDRESS是TFTP服务器监听的IP地址和端口号，TFTP_OPTIONS是TFTP服务器的一些选项，例如安全模式等。

接下来，我们需要创建TFTP服务器的根目录，并设置其权限为777，以便TFTP客户端可以访问其中的文件。我们可以使用以下命令来创建TFTP服务器的根目录：

```bash
sudo mkdir /srv/tftp
sudo chmod 777 /srv/tftp
```

完成上述配置后，我们可以启动TFTP服务器，使其开始监听来自TFTP客户端的请求。我们可以使用以下命令来启动TFTP服务器：

```bash
sudo systemctl enable tftpd-hpa
sudo systemctl start tftpd-hpa
```

这将启动TFTP服务器，并设置其开机自启动。最后，我们可以使用TFTP客户端测试TFTP服务器是否正常工作。例如，我们可以使用以下命令从TFTP服务器中下载一个名为testfile的文件：

```bash
tftp localhost
tftp> get testfile
```

如果文件下载成功，则表示TFTP服务器已经成功安装并配置完成。

以上是安装配置TFTP服务的主要步骤。通过安装和配置TFTP服务器，我们可以实现广告机的远程升级和管理。

#### 3.1.3 串口终端程序的安装配置

串口终端程序是一种常用的调试工具，可以在开发板和电脑之间建立串口连接，显示开发板的调试信息和运行状态。为了在GEC6818开发板上显示调试信息，我们可以使用Secure CRT这个串口终端程序。

Secure CRT是一款常用的串口终端程序，支持多种串口协议和终端模拟器，可以方便地连接到各种嵌入式设备和网络设备上。Secure CRT提供了丰富的调试功能，包括字符显示、颜色配置、发送和接收文件、脚本编写等，可以满足不同的调试需求。

在使用Secure CRT连接开发板之前，我们需要先在电脑上安装和配置串口驱动程序。具体步骤如下：

1.插入串口转USB转接器，并查看其设备名（例如/dev/ttyUSB0）。

2.在电脑上安装串口驱动程序。

3.在Secure CRT中配置串口连接参数，包括波特率、数据位、停止位和校验位等。我们可以在Secure CRT的设置界面中进行配置。例如我们这里在程序中将波特率设置为115200，端口根据设备管理器查看对应的设置。

![image-20230408233536373](C:/Users/%E9%98%BF%E4%B8%83/AppData/Roaming/Typora/typora-user-images/image-20230408233536373.png)

4.连接到开发板的串口，即可在Secure CRT中显示开发板的调试信息和运行状态。

通过以上步骤，我们可以在GEC6818开发板和电脑之间建立串口连接，方便地进行调试和开发工作。

### 3.2 Shell脚本快速调试

Shell脚本是一种可执行文件，它由一系列的命令组成，并且可以被解释器（如bash）执行。它可以用于快速地执行一系列命令，可以实现自动化、批量化的操作，非常适合用于编写自动化脚本、系统管理、软件部署等任务。

Shell脚本可以看作是一种简化版的编程语言，它可以使用各种流程控制结构，如条件语句、循环语句等，还可以使用各种命令来完成各种任务，如文件操作、进程管理等。

Shell脚本一般以.sh作为文件后缀，可以通过chmod命令添加可执行权限，然后通过./文件名的方式运行脚本。

在Linux系统中，Shell脚本是非常常见的一种脚本语言，非常适合用于快速编写各种自动化任务。

为了方便地进行程序调试，我们可以编写一个Shell脚本，使用tftp工具将编译好的程序传输到目标主机上，并通过目标主机上的Shell脚本直接运行程序。

具体实现方法如下：

1.编写一个Shell脚本tftp.sh，内容如下：

```bash
#!/bin/bash
tftp 192.168.0.168 -c put $1 /root/$1
```

该脚本的功能是将第一个参数指定的文件通过tftp传输到IP地址为192.168.0.168的主机上，并存储到/root目录下。

2.将编译好的程序拷贝到与tftp.sh同一目录下，然后执行以下命令：

```bash
./tftp.sh 程序文件名
```

该命令会将编译好的程序传输到目标主机上，并存储到/root目录下。

3.在目标主机上编写一个Shell脚本run.sh，内容如下：

```bash
#!/bin/bash
chmod +x $1
./$1
```

该脚本的功能是将第一个参数指定的程序文件赋予可执行权限，然后运行该程序。

4.在目标主机上执行以下命令：

```bash
./run.sh 程序文件名
```

该命令会执行目标主机上的run.sh脚本，从而运行编译好的程序。

通过以上步骤，我们可以方便地进行程序调试，不需要每次都手动输入命令。Shell脚本快速调试的实现原理是通过tftp工具将程序文件传输到目标主机上，并通过目标主机上的Shell脚本直接运行程序。

以上是关于Shell脚本快速调试的说明。通过编写Shell脚本，我们可以方便地进行程序调试和管理，提高开发效率。

### 3.4 本章小结

本章主要介绍了广告机系统开发平台的搭建，包括嵌入式交叉编译环境的建立、TFTP服务的安装配置、串口终端程序的安装配置以及Shell脚本快速调试。其中，我们首先介绍了嵌入式交叉编译环境的建立，包括交叉编译工具链的安装和配置，以及在开发板上运行程序的方法。

接着，我们详细介绍了TFTP服务的安装配置，该服务可以用于快速地传输文件到目标主机。我们也详细介绍了串口终端程序的安装配置，该程序可以用于在电脑端显示开发板上的调试信息。

最后，我们介绍了如何使用Shell脚本来快速调试程序，该方法可以大大提高开发效率。本章内容详细，希望可以为读者在广告机系统开发平台的搭建过程中提供帮助和参考。

## 4. 第四章 多线程技术研究

### 4.1 多任务机制介绍

在现代计算机系统中，多任务机制是一种常见的实现方式，其可以让多个任务在同一时间段内并行执行。多任务机制的实现可以在硬件层面或软件层面进行。在本文中，我们选择软件层面的实现方式。

软件层面的多任务机制通常依赖于操作系统来实现。操作系统可以将计算机系统资源（如CPU、内存等）划分为不同的部分，然后为不同的任务分配资源。通过这种方式，多个任务可以同时运行，而且彼此之间不会互相影响。

多任务机制的实现可以采用多种方式，其中一种常见的方式是使用线程。线程是操作系统中的一种基本执行单元，它可以在进程内部独立地执行。线程可以共享进程的资源，包括内存空间、文件句柄等。这样，多个线程可以同时运行，并且可以共享相同的资源，从而实现多任务的目的。

另外一种常见的实现方式是使用进程。进程是计算机中的一个独立的执行环境，它拥有自己的地址空间、文件句柄等系统资源。多个进程可以同时运行，它们之间通过进程间通信来实现数据的共享和协作。

在多任务机制的实现过程中，我们需要考虑任务间的同步和互斥问题。同步问题是指多个任务之间的执行顺序问题，互斥问题是指多个任务之间访问共享资源时的竞争问题。这些问题的解决可以采用各种同步机制和互斥机制来实现，如信号量、互斥锁等。

总之，多任务机制是一种常见的实现方式，可以提高计算机系统的并发性和效率。在软件层面上，线程和进程是实现多任务的基本单元，通过各种同步和互斥机制来解决任务间的同步和互斥问题。

#### 4.1.1 进程

进程是计算机系统中的一种基本执行单位，它是操作系统对一个正在运行的程序的抽象。每个进程都有自己的地址空间、文件句柄等系统资源，是操作系统中最基本的资源分配单位。

进程拥有的资源包括CPU时间、内存、文件句柄等。每个进程都有一个独立的虚拟地址空间，其中包括了程序代码、数据、堆栈等信息。操作系统通过分配和管理这些资源来控制进程的执行，保证不同进程之间的资源使用不会相互干扰。进程之间的通信可以通过进程间通信机制实现，如管道、信号量、共享内存等。

进程的引入可以追溯到操作系统的早期阶段，例如1960年代的Multics操作系统中就使用了进程。随着计算机系统的发展，进程的概念变得越来越重要。从1980年代开始，操作系统开始支持多进程的执行模型，这样可以更好地利用计算机系统的资源，提高计算机系统的运行效率。

随着计算机系统的发展，进程之间的通信越来越频繁，操作系统也需要提供更加高效的通信机制。于是在1970年代引入了线程的概念，线程是进程中的一条执行路径，它与其他线程共享进程的资源。线程的引入使得多任务编程变得更加灵活和高效，同时也带来了更多的编程挑战和复杂性。

总之，进程是计算机系统中最基本的资源分配单位，它为操作系统提供了一个独立的执行环境。线程是进程中的基本执行单元，它可以在进程内部独立地执行，与进程共享资源。通过进程和线程的管理，操作系统可以更好地利用计算机系统的资源，提高计算机系统的运行效率。

#### 4.1.1 线程

线程是进程中的一条执行路径，是操作系统中最小的执行单位。与进程不同，线程是共享进程资源的执行单位，一个进程可以包含多个线程。线程在进程内部独立地执行，每个线程都有自己的程序计数器、栈、寄存器等状态信息。

线程拥有的资源包括CPU时间、内存、文件句柄等。由于线程共享进程的资源，因此线程之间的通信和同步要比进程之间的通信和同步更加高效。线程之间的通信可以通过共享内存、消息队列等机制实现。

线程的工作方式是通过线程调度器来完成的。线程调度器负责将CPU时间划分为若干个时间片，然后根据线程的优先级和调度算法来分配时间片给不同的线程，使得每个线程都可以得到执行的机会。线程调度是操作系统的核心功能之一，它可以保证系统的公平性、高效性和可靠性。

线程的引入可以追溯到1970年代，它最初是在操作系统内核中实现的。随着计算机系统的发展，线程逐渐成为操作系统和应用程序的标准功能，现在几乎所有的操作系统都支持线程。

总之，线程是进程内部的一条执行路径，它共享进程的资源，并且比进程之间的通信和同步更加高效。线程的工作方式是通过线程调度器来完成的，它可以保证系统的公平性、高效性和可靠性。线程的引入使得多任务编程变得更加灵活和高效，但同时也带来了更多的编程挑战和复杂性。

#### 4.1.1 多任务机制的选择

实现多任务机制的方式有很多，其中最常用的是线程和进程。通过这两种方式可以实现并发执行和提高程序的效率。下面我们来分别介绍一下线程和进程的实现方式和特点。

线程是进程中的一个执行流程，线程共享进程的地址空间和资源，因此创建和销毁线程的开销相对较小。线程可以轻松实现并发执行，提高程序的效率。由于线程共享进程的资源，因此需要进行同步和互斥来保证多个线程之间的数据安全性。线程的优点在于它的轻量级和高效性。

进程是独立的执行流程，每个进程都有独立的地址空间和资源，因此创建和销毁进程的开销较大。进程可以实现相互独立的并发执行，各自拥有独立的资源和状态信息，因此不需要进行同步和互斥。但是，进程之间的通信和数据共享相对复杂和耗费资源。

综合考虑，我们选择使用线程来实现多任务机制。线程具有轻量级和高效性的优点，在实现并发执行和提高程序效率方面具有优异的表现。同时，线程之间的数据共享相对简单，同步和互斥的开销也较小。因此，我们选择线程作为多任务机制的实现方式。

### 4.2 多线程的实现

在我们选择使用线程来实现多任务机制后，我们需要使用相应的库来实现线程。在本论文中，我们使用的是POSIX线程库（Pthreads），该库是UNIX系统中广泛使用的线程库，可以在不同的平台上使用。POSIX线程库提供了丰富的函数来实现线程的创建、终止、同步和互斥等操作。

在Linux系统中，线程具有很高的地位和重要性，因为Linux系统是一个多用户、多任务的操作系统，线程的使用可以提高系统的效率和响应速度。Linux系统中的线程与进程具有相同的地位，线程可以像进程一样被调度和执行。

在接下来的内容中，我们将详细介绍如何使用Pthreads库来实现线程的创建、终止、同步和互斥等操作。具体而言，我们将介绍Pthreads库中的相关函数，并说明它们的具体作用和使用方法。通过使用这些函数，我们可以轻松地实现线程之间的同步、互斥和并发执行等操作，从而提高程序的效率和响应速度。

#### 4.2.1 线程的创建

在C语言中，我们可以使用POSIX线程库（pthread）来实现多线程的功能。其中，创建一个新线程是使用`pthread_create()`函数。该函数的原型为：

```C
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```

其中，第一个参数`thread`是一个指向`pthread_t`类型的指针，用于存储新线程的ID。创建成功后，该指针将被设置为新线程的ID。

第二个参数`attr`是一个指向`pthread_attr_t`类型的指针，用于设置线程的属性，例如线程的调度策略、优先级、栈大小等。如果不需要设置这些属性，可以将该参数设置为NULL。

第三个参数`start_routine`是指向线程函数的指针，新线程将从该函数开始执行。该函数必须返回一个指向`void`类型的指针，同时接受一个指向`void`类型的指针作为参数。

第四个参数`arg`是一个指向线程函数参数的指针。如果线程函数不需要参数，可以将该参数设置为NULL。

`pthread_create()`函数的返回值为0表示创建线程成功，否则表示失败，并返回相应的错误码。

通过调用`pthread_create()`函数，我们可以成功创建一个新的线程，并在该线程中执行指定的线程函数。

#### 4.2.2 线程的终止

线程的终止通常是由于任务已完成或者出现了错误而引起的。为了避免资源泄漏，线程的结束需要进行资源回收。如果不及时回收线程的资源，会导致内存泄漏等问题，进而影响程序的性能和稳定性。

在Linux中，线程的终止可以通过pthread_join()函数实现。该函数的原型为：

```C
int pthread_join(pthread_t thread, void **retval);
```

该函数的第一个参数thread是要等待的线程ID，retval是一个指向指针的指针，用于存储被等待线程的退出状态。该函数的返回值为0表示成功，否则表示失败。

另外，在一些情况下，线程的资源可能需要在它退出时被立即回收。这可以通过pthread_detach()函数实现，该函数会将指定线程标记为可分离的，并在线程退出时自动回收资源。该函数的原型为：

```C
int pthread_detach(pthread_t thread);
```

该函数的参数thread是要分离的线程ID。该函数的返回值为0表示成功，否则表示失败。

因此，在实际的程序设计中，需要根据实际情况选择合适的方法对线程进行回收，以确保程序的稳定性和性能。

#### 4.2.3 线程的执行特性与优先级

线程作为一个独立的执行单元，其状态可能会有多种，包括就绪态、运行态、阻塞态等。线程的状态转换是由操作系统内核调度决定的。在调用线程的创建函数后，线程进入就绪态等待被调度。当系统为其分配CPU资源时，线程会进入运行态执行其任务。而当线程需要等待某些事件完成时，例如等待输入输出完成等，线程会进入阻塞态等待事件完成。线程也可能被操作系统调度器中止执行，此时线程状态为挂起态。

线程的优先级用来决定调度器在多个线程就绪时，选择哪个线程获得CPU资源。较高优先级的线程通常会先于较低优先级的线程执行。线程的优先级是由操作系统决定的，通常使用数字表示，范围从0到255。Linux系统中，使用nice值来表示线程的优先级。nice值越小，优先级越高。线程的默认优先级通常是中等程度的，可以通过设置nice值来改变线程的优先级。

在线程执行过程中，可以使用pthread_setschedparam函数来改变线程的调度优先级，以提高线程的执行效率。该函数的参数包括线程ID、调度策略和优先级，可以使用该函数将线程的优先级提高或降低。

#### 4.2.4 线程的互斥

线程的互斥是为了避免多个线程同时访问共享资源而导致的数据不一致等问题。Linux系统中提供了两个主要的互斥机制，分别是mutex和spinlock。其中，mutex是基于休眠和唤醒机制实现的，而spinlock则是基于忙等待实现的。

为了使用mutex，我们需要先创建一个互斥变量，可以通过调用pthread_mutex_init函数来完成。该函数的原型为：

```c++
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
```

其中，mutex参数是指向互斥变量的指针，attr参数用于设置互斥变量的属性，一般可以设置为NULL。

创建好互斥变量后，我们可以使用pthread_mutex_lock和pthread_mutex_unlock函数来实现对共享资源的互斥访问。其中，pthread_mutex_lock用于获取互斥锁，如果该锁已经被其他线程占用，则当前线程会被阻塞，直到该锁被释放为止。pthread_mutex_unlock则用于释放互斥锁，使得其他线程可以继续访问共享资源。

pthread_mutex_lock和pthread_mutex_unlock函数的原型分别为：

```C
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

需要注意的是，在使用互斥锁时需要保证加锁和解锁的顺序正确，否则可能会导致死锁等问题。同时，还需要注意对共享资源的访问是否受到互斥保护，以确保多个线程访问共享资源时不会发生数据不一致等问题。

总之，线程的互斥机制是多线程编程中非常重要的一个概念，能够有效避免多个线程同时访问共享资源而导致的问题，从而保证程序的正确性和稳定性。

#### 4.2.5 线程的同步

线程同步是指多个线程按照一定的顺序来共享和访问共享资源。同步的作用是防止多个线程同时访问共享资源导致的数据不一致问题。线程同步通过使用同步变量实现，常用的同步变量包括信号量和条件变量。

信号量是一个整型变量，用于保证多个线程之间的同步和互斥。在多线程编程中，信号量是一种经典的同步工具。信号量可以看作是一个计数器，线程可以对其进行P操作（等待信号量）和V操作（释放信号量），以控制对共享资源的访问。可以使用pthread库提供的函数进行创建、初始化、等待和释放信号量。其中，创建和初始化信号量的函数是sem_init，该函数原型为：

```C
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

其中，第一个参数sem是指向要初始化的信号量的指针，第二个参数pshared表示信号量是在进程间共享还是在线程间共享，通常为0表示在线程间共享，第三个参数value表示信号量的初值。

等待信号量的函数是sem_wait，该函数原型为：

```C
arduinoCopy code
int sem_wait(sem_t *sem);
```

其中，sem为要等待的信号量的指针，如果信号量值为0，则该函数会阻塞当前线程，直到信号量值大于0。

释放信号量的函数是sem_post，该函数原型为：

```C
int sem_post(sem_t *sem);
```

其中，sem为要释放的信号量的指针，该函数会将信号量值加1，如果有其他线程等待该信号量，则会唤醒其中一个线程。

条件变量是一种线程间同步机制，它可以使线程在满足某个特定条件之前一直等待。可以使用pthread库提供的函数进行创建、销毁、等待和发送信号给条件变量。其中，创建和销毁条件变量的函数分别是pthread_cond_init和pthread_cond_destroy，它们的原型为：

```C
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
int pthread_cond_destroy(pthread_cond_t *cond);
```

其中，cond为要创建或销毁的条件变量的指针，attr为指向条件变量属性的指针，通常为NULL表示使用默认属性。

等待条件变量的函数是pthread_cond_wait，该函数原型为：

```C
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
```

其中，cond为要等待的条件变量的指针，mutex为互斥锁的指针，该函数会自动释放互斥锁，并使当前线程阻塞，直到收到一个信号或者被信号中断。

发送信号给条件变量的函数是pthread_cond_signal，该函数原型为：

```C
int pthread_cond_signal(pthread_cond_t *cond);
```

其中，cond为要发送信号的条件变量的指针，该函数会唤醒至少一个正在等待该条件变量的线程。

通过使用信号量和条件变量等同步工具，可以避免多线程编程中的一些典型问题，如死锁、竞争条件、优先级反转等，从而提高多线程程序的可靠性和稳定性。

### 4.3 本章小结

在本章中，我们深入探讨了线程的基础知识以及如何在C语言中使用线程。我们首先介绍了线程的定义和作用，并通过示例代码展示了如何创建和使用线程。接着我们讨论了线程的执行特性和优先级，包括线程的状态转换和线程优先级的作用。接下来我们介绍了如何通过互斥锁、信号量和条件变量等同步机制来保证多个线程之间的安全访问共享资源。了解了如何使用同步机制来避免多线程并发访问共享资源时可能出现的问题。

## 5. 广告机应用软件的开发与实现

### 5.2 广告机应用程序的具体实现

#### 5.2.1 程序总体框架

本文所设计实现的广告投放机程序基于GEC6818开发平台，主要包括路径获取模块、触控模块、图片显示模块和文字模块四个模块。该程序的主要功能是读取u盘以及GEC6818开发版上指定目录下的bmp格式的文件，显示当前日期并支持自动轮播和手动滑动两种方式展示广告图片，同时可以通过更换u盘下的指定文件夹内的图片来实现更换广告的效果。

路径获取模块是该程序的基础模块，主要负责获取程序所需要的图片和字体文件的路径。在程序启动时，该模块会读取配置文件中的路径信息，并将其存储到全局变量中供其他模块使用。

触控模块是该程序的交互模块，主要负责响应用户的手势操作。该模块通过触摸屏输入获取用户手势信息，识别手势类型并传递给图片显示模块进行相应的处理。

图片显示模块是该程序的核心模块，主要负责展示广告图片。该模块通过多线程的方式实现，一个线程负责显示当前日期，另一个线程负责轮播和手动切换广告图片。该模块通过读取u盘以及GEC6818开发版上指定目录下的bmp格式的文件，将其显示在屏幕上。同时支持自动轮播和手动切换两种方式，用户可以通过手势操作进行广告图片的切换。

文字模块是该程序的辅助模块，主要负责在屏幕上显示当前日期。该模块会在图片显示模块启动时启动一个线程，负责实时更新并显示当前日期。同时，该模块还提供了字体文件的加载和使用功能，以便于在广告图片中添加文字信息。

综上所述，该程序实现了基于GEC6818开发平台的广告投放机的设计与实现，并具有路径获取、触控、图片显示和文字显示等多个模块，支持读取u盘以及GEC6818开发版上指定目录下的bmp格式的文件，显示当前日期，并支持自动轮播和手动切换两种方式展示广告图片，具有良好的用户交互性和实用性。

#### 5.2.3 路径获取模块实现

在本研究中，为了实现广告机的路径获取模块，我们设计并实现了一个路径获取算法，该算法采用了自己实现的栈和队列。我们使用readdir函数来获取目录下的所有文件路径，并使用裁剪函数来判断文件名的后缀是否为bmp图片，以便筛选出需要的图片。最后，我们将获取到的路径存储在一条双向链表中，以便在后续的广告展示过程中使用。

在路径获取模块的实现中，技术实现的重点包括以下几个方面：

1. 使用readdir函数获取目录下的所有文件路径：readdir函数是一个C标准库函数，用于读取指定目录下的所有文件和子目录的名称。

    其原型为：

    ```C++
    struct dirent *readdir(DIR *dirp)
    ```

    其中DIR是一个指向目录的流指针，dirent是一个结构体，用于存储目录中的文件名和类型等信息。

2. 读取文件的类型和名称：在使用readdir函数获取目录下的文件名后，我们可以通过dirent结构体中的d_name成员变量来获取文件名。对于文件类型，我们可以使用dirent结构体中的d_type成员变量，其中DT_REG表示文件，DT_DIR表示目录。

3. 判断文件后缀名是否为bmp：为了筛选出需要的bmp图片，我们需要对文件名的后缀名进行判断。在本研究中，我们使用了裁剪函数和字符串比较函数来实现此功能。具体而言，我们使用了strstr函数来判断字符串中是否包含指定的子字符串（即".bmp"），如果包含则返回该子字符串在原字符串中的位置，否则返回NULL。通过这种方法，我们可以判断文件名的后缀名是否为bmp。

通过本算法的实现，我们能够有效地获取指定目录下的所有bmp格式的图片路径，并且能够方便地在广告展示过程中使用。该算法具有较高的可靠性和实用性，能够为广告机的正常运行提供有力的支持。在接下来的研究工作中，我们将继续完善该算法，并进一步提高广告机的性能和稳定性。

#### 5.2.4 触控模块实现

在本文中，我们介绍了基于GEC6818开发平台的广告投放机的设计与实现的第四部分，即触控模块的实现。触控模块是广告投放机的重要组成部分，它能够实现用户与系统之间的交互，方便用户管理和操作广告内容。在设计和实现触控模块时，我们需要考虑到不同用户的使用习惯和需求，同时保证系统的稳定性和可靠性。因此，我们采用了GEC6818开发平台提供的触控屏幕，并通过打开/dev/input/event0设备来读取触控信息。

为了读取触控信息，我们定义了一个结构体input_event ev来存储信息。该结构体包括了时间、事件类型、事件代码和事件的值等成员，可以提供丰富的信息来帮助我们实现不同的屏幕操作，包括滑动、点击和长按等。通过读取触控信息，我们可以获取用户的输入，并根据不同的操作来实现相应的功能。例如，在广告投放机中，我们可以通过触控操作来切换不同的广告内容，实现投放效果的优化和管理。

在实现触控功能时，我们采用了非阻塞的方式进行读取触控信息。这种方式可以保证系统的响应速度和稳定性，同时减少了对CPU资源的占用，提高了系统的性能。为了实现自动换图片和手动换图片功能，我们需要判断用户是否有滑动屏幕的操作，并计算出滑动的方向。为了方便计算，我们定义了一个函数GetTouchDrop_Silther()，通过对滑动最开始的flag_x与flag_y 与最后手指离开屏幕的 flag_x与flag_y 进行计算，得出滑动的方向，并返回枚举类型Move_Dir，包括RIGHT、LIFT、UP、DOWN、DBCLICK、CLICK、LongPress和DIR_ERROR等。在函数的实现过程中，我们需要考虑到不同的屏幕分辨率和大小，以及不同用户的操作习惯和需求，确保计算结果的准确性和实用性。

除了实现基本的触控功能外，我们还需要考虑到用户的体验和操作便捷性。例如，在广告投放机中，我们通过判断用户在手动换图片后10秒内是否有操作，来决定是否进入自动换图片的模式。这种设计可以避免用户频繁操作屏幕，减少用户的疲劳感，提高用户的使用体验。同时，在操作界面和提示信息的设计中，我们也需要考虑到用户的需求和操作习惯，以及界面的美观和易用性,我们采用了简洁明了的操作界面.

总之，触控模块是广告投放机的重要组成部分，能够实现用户与系统之间的交互，方便用户管理和操作广告内容。在设计和实现触控模块时，我们需要考虑到不同用户的使用习惯和需求，同时保证系统的稳定性和可靠性。我们采用了GEC6818开发平台提供的触控屏幕，并通过打开/dev/input/event0设备来读取触控信息，实现了基本的触控功能。在功能实现的过程中，我们还需要考虑到用户的体验和操作便捷性，采用了简洁明了的操作界面和多种操作方式和快捷键，让用户可以轻松地操作系统。

#### 5.2.5 图片显示模块的实现

在图片显示模块中，读取BMP图片文件并将其还原为RGB像素点是必须的。BMP是Windows系统下的一种图像文件格式，其数据存储方式比较简单，适合于嵌入式系统等资源有限的场景。

BMP文件格式中的位图数据存储方式与普通的图片格式不同，需要进行解析和转换。具体而言，BMP文件包含文件头和位图数据两部分，其中文件头记录了图像的基本信息，如图像宽度、高度、色深等，而位图数据则记录了每个像素点的颜色信息。

读取BMP文件并还原为RGB像素点的一般流程如下：

1. 读取BMP文件头信息，解析出图片的宽度、高度、色深等信息。

    bmp文件的头部信息包含了图像的基本属性，包括图像的宽度、高度、色深等。bmp文件的头部信息通常存储在文件的最前面，其大小为14个字节。

    其中，前两个字节为文件类型标识，应为“BM”。接下来的四个字节为文件大小，以字节为单位。紧接着的四个字节为保留字段，通常为0。之后的四个字节表示位图数据区相对于文件起始处的偏移量，也就是说，前面所有的字节都属于头部信息，而位图数据区从偏移量处开始。

    在读取bmp文件时，我们需要先读取14个字节的头部信息，并解析其中的宽度、高度、色深等属性。具体而言，我们可以使用如下的结构体来表示bmp文件头：

    ```C++
    typedef struct {
        uint16_t type;              // 文件类型，必须为BM
        uint32_t size;              // 文件大小，以字节为单位
        uint16_t reserved1;         // 保留字段1，必须为0
        uint16_t reserved2;         // 保留字段2，必须为0
        uint32_t offset;            // 位图数据区相对于文件起始处的偏移量，以字节为单位
        uint32_t info_size;         // 信息头大小，以字节为单位
        int32_t width;              // 图像宽度，以像素为单位
        int32_t height;             // 图像高度，以像素为单位
        uint16_t planes;            // 图像的位面数，必须为1
        uint16_t bits_per_pixel;    // 每个像素所占位数，常见值为24
        uint32_t compression;       // 压缩方式，常见值为0（不压缩）
        uint32_t image_size;        // 位图数据区大小，以字节为单位
        int32_t x_pixels_per_meter; // 水平分辨率，以像素每米为单位
        int32_t y_pixels_per_meter; // 垂直分辨率，以像素每米为单位
        uint32_t colors_used;       // 颜色索引数，为0表示使用所有调色板
        uint32_t colors_important;  // 重要的颜色索引数，如果为0表示都重要
    } bmp_header_t;
    ```

    在解析完bmp文件头后，我们可以根据文件中位图数据区的偏移量来读取位图数据，并将其还原成rgb像素点。

2. 根据BMP文件头信息中的位图数据偏移值，定位到位图数据区，读取数据。

3. 对于24位色深的BMP图片，每个像素点由3个字节组成，分别表示红、绿、蓝三个颜色分量，需要将其转换为RGB像素点。这一过程可以使用如下函数实现：

```C++
void bmp24_to_rgb(unsigned char* bmp24_data, unsigned int width, unsigned int height, unsigned char* rgb_data)
{
    int row_size = width * 3; // 每行字节数
    int pad_size = row_size % 4; // 每行补齐字节数
    if (pad_size != 0) pad_size = 4 - pad_size; // 计算补齐字节数
    int offset = row_size + pad_size; // 计算每个像素点的偏移量
    int idx = 0;
    for (int j = height - 1; j >= 0; j--) {
        for (int i = 0; i < width; i++) {
            int r = bmp24_data[j * offset + i * 3 + 2];
            int g = bmp24_data[j * offset + i * 3 + 1];
            int b = bmp24_data[j * offset + i * 3];
            rgb_data[idx++] = r;
            rgb_data[idx++] = g;
            rgb_data[idx++] = b;
        }
    }
}
```

当我们完成了对bmp图片的读取与像素点还原后，需要将这些像素点数据写入帧缓冲设备的映射内存中，以便在屏幕上显示图片。在这个过程中，我们采用了帧缓冲设备的操作流程，分为以下几个步骤：

1. 打开屏幕设备文件

在开始操作帧缓冲设备之前，我们需要先打开设备文件，也就是/dev/fb0文件。这个文件是Linux操作系统中与帧缓冲设备对应的设备文件，通过打开该文件，我们可以访问帧缓冲设备，从而进行后续操作

2. 获取屏幕信息

打开设备文件后，我们需要使用ioctl函数调用来获取屏幕的分辨率、色深等信息。这些信息将会在后续的像素点写入过程中用到，我们需要提前获取并保存这些信息。

3. 映射内存

在获取屏幕信息之后，我们需要使用mmap函数将帧缓冲设备的映射内存区域映射到用户空间。这个过程中，我们需要指定映射的内存大小、权限、偏移量等信息。映射完成后，我们可以直接对映射内存区域进行读写操作，以便将像素点数据写入内存中。

4. 操作映射内存

在完成映射后，我们就可以开始将还原出来的RGB像素点数据写入帧缓冲设备的映射内存中了。这个过程中，我们需要使用已经获取到的屏幕信息来计算每个像素点在映射内存中的位置，从而进行像素点写入操作。在写入完成后，我们可以通过屏幕设备文件将这些像素点数据实时显示在屏幕上。

5. 解映射内存

当所有像素点数据都已经写入映射内存后，我们需要使用munmap函数将映射内存解除映射，以释放资源。这个过程中，我们需要传入之前映射内存时指定的内存地址和大小等信息。

6. 关闭屏幕设备文件

最后，我们需要使用close函数关闭屏幕设备文件，以结束本次操作。这个过程中，我们需要传入之前打开设备文件时返回的文件描述符。

#### 5.2.6 文字模块的实现

在本论文的广告投放机设计中，为了实现在屏幕上面显示日期的功能，需要先实现显示文字的基础模块。在该模块中，我们使用取模软件取模，将文字转化为点阵信息，并将其存储在一个全局 unsigned char 数组 SchName[6][40*35/8] 中。接下来，我们需要实现一个显示文字的函数。

该函数名为 Lcd_DrawWord，其参数包括文字显示的起始坐标 x0 和 y0，以及文字的宽度 w 和高度 h。此外，还需要传入点阵信息的指针 data 和颜色 color。在该函数中，我们首先通过两重循环遍历点阵信息，将其转化为像素点，并使用 Lcd_DrawPoint 函数在屏幕上面进行显示。

```C++
void Lcd_DrawWord(int x0,int y0,int w,int h,char *data,int color)
{
	int i,k;
	
	for(i=0;i < w*h/8;i++)
	{
		for(k=0;k<8;k++)
		{
			if((data[i]<<k)&0x80)
			{
				Lcd_DrawPoint(x0+(i*8+k)%w,y0+i/(w/8),color);
			}
		}			
	}
}
```



具体而言，对于点阵信息中的每个字节，我们需要再进行 8 次遍历，以确定该字节中每个位的状态。若某个位为 1，则表示该位置需要显示文字，我们则使用 Lcd_DrawPoint 函数在相应的坐标上进行绘制。

通过以上实现，我们可以实现在屏幕上面显示各种文字信息的功能，包括本论文所需的日期显示功能。

### 5.3 系统测试的结果

在Linux平台将应用程序开发完成之后，使用gcc编译完成之后，将编译好的程序传入GEC6818开发板。由于开发板事先就已经移植好了Linux操作系统，所以可以直接运行程序，广告机的整体运行效果如下图：



运行结果证明，基于GEC6818开发平台的广告投放机系统运行良好，显示正常，具有一定的实用价值。

### 5.4 本章小结

本章详细介绍了广告机系统应用的软件实现过程，包括程序的总体框架以及构成程序的各个模块的具体实现。其中，路径获取模块实现了获取程序所需的图片和字体文件的路径信息，并将其存储到双向链表中；触控模块通过触摸屏输入获取用户手势信息，并传递给图片显示模块；图片显示模块实现了图片的自动轮播和手动滑动两种方式，并支持更换广告图片的功能；文字模块实现了在屏幕左上角显示当前日期的功能。最后，系统测试结果表明该系统实现了预期的功能，具有良好的稳定性和可靠性。

## 6.总结与展望
### 6.1 工作总结



### 6.2 问题和展望



### 6.3 本章小结

## 致谢

在这里，我要向我的指导老师XXX表达我最深的感激之情。他在我论文的方方面面给予了我巨大的帮助，包括论文选题、研究方法、实验设计以及最终的定稿等。他的耐心指导、严谨治学的作风和扎实的科研精神，对我的论文起到了至关重要的作用。在整个论文的研究过程中，他始终给予我充分的支持和鼓励，让我在不断地探索中收获了许多宝贵的经验和知识。他还不断地督促我不断完善论文，不断提高论文的质量。在这个过程中，我深深地感受到了他对学术研究的认真和敬业，这让我深受启发和感动。此外，他还经常与我分享自己的学术经验和心得，对我的研究方法和论文写作等方面提供了很多宝贵的指导。他不仅是一位出色的学者，更是一位优秀的导师，他的工作做风和科研精神都值得我深深地敬佩和学习。在此，我要向他致以最诚挚的谢意，感谢他在我论文研究中所付出的巨大精力和心血。

此外，我还要感谢曾经帮助过我的同学和老师。他们在我学习和论文研究的过程中，给予了我很多宝贵的建议和支持，帮助我克服了许多困难。他们的专业知识和热情，让我在学术探索中得到了很大的启发和帮助。我也深深地感谢他们对我的关心和帮助，他们的友谊和支持对我来说意义深远。在此，我要向他们表达最诚挚的谢意和祝福。

## 参考文献

